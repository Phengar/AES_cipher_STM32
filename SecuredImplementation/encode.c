#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h> 
#include <sys/time.h>


#define BILLION  1000000000.0



static const unsigned char multGalois0x01[256] = {
0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
};

static const unsigned char multGalois0x02[256] = {
0x0, 0x2, 0x4, 0x6, 0x8, 0xa, 0xc, 0xe, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0xb, 0x9, 0xf, 0xd, 0x3, 0x1, 0x7, 0x5,
0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5,
};

static const unsigned char multGalois0x03[256] = {
0x0, 0x3, 0x6, 0x5, 0xc, 0xf, 0xa, 0x9, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
0xb, 0x8, 0xd, 0xe, 0x7, 0x4, 0x1, 0x2, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a,
};

static const unsigned char sbox[256] = {
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 
};

static const unsigned char rcon[11] = {
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 
};

static const unsigned char message[16] = {
    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
};

static const unsigned char key[16] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};


void print_key_16(unsigned char *keyW){ //debug function
    for(int i=0; i<16; i++){
        printf("%x", keyW[i]);
    }
}


//multGalois isn't optimal as the only values of b are 1,2 and 3

unsigned char multGalois(unsigned char a, unsigned char b){
    unsigned char p=0;
    for (int i=0; i<8; i++){
        if ((b & 0x01) == 0x01){
            p^=a;
        }
        if ((a & 0x80) == 0x80){
            a<<=1;
            a^=0x1b;
        }else{
            a<<=1;
        }
        b>>=1;
    }
    return p;
}


// implementation of Galois multiplication optimised for b=1,2,3

unsigned char multGalois_opti(unsigned char a, unsigned char b){//si Ã§a c'est pas de l'optimisation
    unsigned char p;
    switch(b){
        case 0x01: return a;    //multiplication by 1=00000001
        case 0x02: return ((a&0x80) == 0x80) ? (a<<1)^0x1b : a<<1; //multiplication by 2==00000010
        case 0x03: return ((a&0x80) == 0x80) ? a^(a<<1)^0x1b : a^(a<<1); //multiplication by 3==00000001
        default: printf("\n error in Galois mult: b=%x\n",b); exit(1); //catch errors
    }
}

unsigned char multGalois_opti2(unsigned char a, unsigned char b){
    switch(b){
        case 0x01: return multGalois0x01[a];    
        case 0x02: return multGalois0x02[a]; 
        case 0x03: return multGalois0x03[a];
        default: printf("\n error in Galois mult: b=%x\n",b); exit(1); //catch errors
    }
}

void mixColumns_4(unsigned char * keyPart){ //multiply Galois matrix with vector keyPart
    unsigned char save[4]={keyPart[0], keyPart[1], keyPart[2], keyPart[3]}, mix[4]={0x02, 0x03, 0x01, 0x01}; //saves the part of the key to modify the key directly without losing data
    for (int i=0;i<4;i++){ 
        keyPart[0]=0;
        keyPart[1]=0;
        keyPart[2]=0;
        keyPart[3]=0;
    }
    for (int i=0;i<4;i++){ // consecutive multiplication of the part of the key
        keyPart[0]^=multGalois(save[i], mix[i]);
        keyPart[1]^=multGalois(save[i], mix[(i+3)%4]);
        keyPart[2]^=multGalois(save[i], mix[(i+2)%4]);
        keyPart[3]^=multGalois(save[i], mix[(i+1)%4]);
    }
}

void mixColumns_16(unsigned char *State){// multiply each 4bytes vector one by one with mixColumns_4
    unsigned char temp[4];
    for (int i=0; i<4; i++){
        for (int j=0; j<4; j++){
            temp[j]=State[i*4+j];
        }
        mixColumns_4(temp);
        for (int j=0; j<4; j++){
            State[i*4+j]=temp[j];
        }
    }
}

void rotate_key(unsigned char * keyPart){ //rotation on 4 bytes part of the key
    unsigned char temp=keyPart[0];
    for (int i=0; i<3; i++){
        keyPart[i]=keyPart[i+1];
    }
    keyPart[3]=temp;
}

void SBox_4(unsigned char *keyPart){ //Sbox for the key schedule
    for(int i=0; i<4; i++){
        keyPart[i]=sbox[keyPart[i]];
    }
}

void SBox_16(unsigned char *State){ //Sbox for the state
    for(int i=0; i<16; i++){
        State[i]=sbox[State[i]];
    }
}

void ShiftRows(unsigned char *State){ //Rotations for the state
    unsigned char temp1=State[1],temp2=State[2];
    State[1]=State[5]; State[5]=State[9]; State[9]=State[13]; State[13]=temp1;
    temp1=State[6]; State[2]=State[10]; State[6]=State[14]; State[10]=temp2; State[14]=temp1;
    temp1=State[15]; State[15]=State[11]; State[11]=State[7]; State[7]=State[3]; State[3]=temp1;
}

void RCon(unsigned char *keyPart, int i){ //Rcon operation for key schedule
    keyPart[0] ^= rcon[i];
}

void keySch(unsigned char *keyPart, int i){ //KEY SCHEDULE
    rotate_key(keyPart);
    SBox_4(keyPart);
    RCon(keyPart,i);
}

void AddRoundKey(unsigned char *a, unsigned char *b){ //modify a to a^b
    for (int i=0; i<16; i++){
        a[i] ^= b[i];
    }
}



//int main(int argc, unsigned char *argv[]){
//   /* struct timespec start, end;
//   if(argc<3){ //catch error
//       printf("please supplie the message to encode and the key");
//       exit(1);
//   }
//    if(sizeof(argv[2])/sizeof(unsigned char)!=16){ //catch error
//        printf("size of key is %d when it should be 16\n", sizeof(argv[2])/sizeof(unsigned char));
//    }
//    if(sizeof(argv[1])/sizeof(unsigned char)!=16){ //catch error
//        printf("size of message is %d when it should be 16\n", sizeof(argv[2])/sizeof(unsigned char));
//    }
//    for( int i=0; i<16; i++){// for tests on static constants
//        argv[2][i]=key[i];
//        argv[1][i]=message[i];
//    }*/
//    /*printf("round[0].input ");
//    print_key_16(argv[1]);
//    printf("\n");
//    printf("round[0].k_sch ");
//    print_key_16(argv[2]);
//    printf("\n");*/
//    AddRoundKey(argv[1],argv[2]);
//    for (int i=1;i<11; i++){
//        /*printf("round[%d].start ", i);
//        print_key_16(argv[1]);
//        printf("\n");*/
//        SBox_16(argv[1]);  //SBOX
//        /*printf("round[%d].s_box ", i);
//        print_key_16(argv[1]);
//        printf("\n");*/
//        ShiftRows(argv[1]);  //SHIFTROWS
//        /*printf("round[%d].s_row ", i);
//        print_key_16(argv[1]);
//        printf("\n");*/
//        if(i != 10){
//            //long long int begin = GetTickCount64();
//            mixColumns_16(argv[1]);  //MIXCOLUMNS
//            /*long long int end = GetTickCount64();
//            double elapsed = (end - begin)*1e-3;
//            printf("Time measured: %.3f seconds.\n", elapsed);
//            printf("round[%d].m_col ", i);
//            print_key_16(argv[1]);
//            printf("\n");*/
//        }
//        unsigned char save[4];
//        for (int k=0; k<4; k++){
//            save[k]=argv[2][12+k];
//        }
//        keySch(save,i);  //ROUNDKEYS
//        for (int j=0; j<4; j++){
//            argv[2][j]^= save[j];
//            argv[2][4+j]^= argv[2][j];
//            argv[2][8+j]^= argv[2][4+j];
//            argv[2][12+j]^= argv[2][8+j];
//        }
//        /*printf("round[%d].k_sch ", i);
//        print_key_16(argv[2]);
//        printf("\n");*/
//        AddRoundKey(argv[1],argv[2]); //ADDROUNDKEY
//    } 
//    printf("Encrypted message: ");
//    print_key_16(argv[1]);  //DECRYPTED
//}


int main(int argc, char *argv[]) {

    unsigned char i;
    unsigned char str_len;
    unsigned int val;
    unsigned char plaintext[16], ciphertext[16];
    unsigned char key[16]= {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
   unsigned int bufferIn[50];
    
    //Load plaintext
     str_len = strlen(argv[1]);
     for (i = 0; i < (str_len / 2); i++) {
         sscanf(argv[1] + 2*i, "%02x", &bufferIn[i]);
         //printf("bytearray %d: %02x\n", i, bufferIn[i]);
         plaintext[i] = bufferIn[i];
     }

     printf("INPUT:     ");
     for(i = 0; i<16; i++){
       printf("%02x ", plaintext[i]);
    }
    
/////////////////// ici votre AES////////////
    /*printf("round[0].input ");
    print_key_16(plaintext);
    printf("\n");
    printf("round[0].k_sch ");
    print_key_16(key);
    printf("\n");*/
    AddRoundKey(plaintext, key);
    for (int i=1;i<11;i++){
        /*printf("round[%d].start ", i);
        print_key_16(argv[1]);
        printf("\n");*/
        SBox_16(plaintext);
        /*printf("round[%d].s_box ", i);
        print_key_16(plaintext);
        printf("\n");*/
        ShiftRows(plaintext);
        /*printf("round[%d].s_row ", i);
        print_key_16(plaintext);
        printf("\n");*/
        if (i!=10){
            mixColumns_16(plaintext);
            /*printf("round[%d].m_col ", i);
            print_key_16(argv[1]);
            printf("\n");*/
        }
        unsigned char save[4];
        for (int k=0; k<4; k++){
            save[k]=key[12+k];
        }
        keySch(save,i);  //ROUNDKEYS
        for (int j=0; j<4; j++){
            key[j]^= save[j];
            key[4+j]^= key[j];
            key[8+j]^= key[4+j];
            key[12+j]^= key[8+j];
        }
        AddRoundKey(plaintext,key);
    }
/////////////////// ici votre AES////////////


printf("\nOUTPUT:    ");
for(i = 0; i<16; i++){
  printf("%02x ", plaintext[i]);
}
printf("\n");

}

